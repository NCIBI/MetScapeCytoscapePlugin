/************************************************************************* * Copyright 2012 Regents of the University of Michigan  *  * NCIBI - The National Center for Integrative Biomedical Informatics (NCIBI) *         http://www.ncib.org. *  * This product may includes software developed by others; in that case see specific notes in the code.  *  * This program is free software: you can redistribute it and/or modify it under the terms * of the GNU General Public License as published by the Free Software Foundation,  * either version 3 of the License, or (at your option) any later version, along with the following terms: * 1.	You may convey a work based on this program in accordance with section 5,  *      provided that you retain the above notices. * 2.	You may convey verbatim copies of this program code as you receive it,  *      in any medium, provided that you retain the above notices. *  * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. *  * See the GNU General Public License for more details, http://www.gnu.org/licenses/. *  * This work was supported in part by National Institutes of Health Grant #U54DA021519 * ******************************************************************/package org.ncibi.cytoscape.metscape.multidisplay.gui.barchart;// Copied and modified from http://www.superliminal.com/sources/BarChart.java.html// Modified for integration needs - Oct 8, 2010  - Terry E Weymouth// BarChart.javaimport java.awt.Color;import java.awt.Dimension;import java.awt.Font;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Point;import java.awt.Rectangle;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;import javax.swing.JPanel;import org.ncibi.cytoscape.metscape.multidisplay.gui.model.ColorRange;import org.ncibi.cytoscape.metscape.multidisplay.gui.model.ColorRangeChangeListener;import org.ncibi.cytoscape.metscape.multidisplay.gui.model.ControlInterface;import org.ncibi.cytoscape.metscape.multidisplay.gui.model.MinMaxChangeListener;import org.ncibi.cytoscape.metscape.multidisplay.gui.model.MinMaxValueModel;/** * Generic bar chart class with full selection set support. *  * @author Melinda Green */@SuppressWarnings("serial")public class Histogram extends JPanel implements MinMaxChangeListener, ColorRangeChangeListener{	private static final int CHART_LEFT_PAD = 40, CHART_RIGHT_PAD = 10,	CHART_TOP_PAD = 10, CHART_BOTTOM_PAD = 40, CHART_MIN_DIM = 300,	MAX_TIC_LABELS = 10, // greatest number of axis tic labels	TIC_LENGTH = 4; // length of axis tic marks//	private static final int MIN_BOX_WIDTH_FOR_SEPERATOR = 9; // looks crummy if too small	private final static String NO_VALUES_MSG = "No Bar Values Set";//	private static final Color HIGHLIGHT_COLOR = Color.yellow;	private final ControlInterface control;	private String xAxisLabel, yAxisLabel;	private SelectionSet selections;	private int anchorSelectionIndex = 0; // base index for range selections	private final Rectangle tmpRect = new Rectangle(); // scratch space	/**	 * Constructs default, Histogram panel.	 */	public Histogram(ControlInterface control) {		this(control, null,null,null);	}	/**	 * constructs a BarChart panel.	 * 	 * @param xAxisLabel	 *            - String to draw on x axis - optional.	 * @param yAxisLabel	 *            - String to draw on y axis - optional.	 * @param sel	 *            is an optional SelectionSet. the bar chart class always	 *            maintains a SelectionSet object which it updates on UI	 *            selections. callers may call getSelectionSet to monitor	 *            BarChart selections and to make selection changes which the	 *            BarChart will respond to. if a non-null SelectionSet parameter	 *            is provided here, the BarChart will listen to and modify the	 *            given one instead.	 */	public Histogram(final ControlInterface control,			String xAxisLabel, String yAxisLabel, SelectionSet sel) {		this.control = control;		this.xAxisLabel = xAxisLabel;		this.yAxisLabel = yAxisLabel;		if (sel == null) sel = new SelectionSet(HistogramBarValue.class);		setSelectionSet(sel);		setMinimumSize(new Dimension(CHART_MIN_DIM + CHART_LEFT_PAD				+ CHART_RIGHT_PAD, CHART_MIN_DIM + CHART_TOP_PAD				+ CHART_BOTTOM_PAD));		setSize(new Dimension(CHART_MIN_DIM + CHART_LEFT_PAD				+ CHART_RIGHT_PAD, CHART_MIN_DIM + CHART_TOP_PAD				+ CHART_BOTTOM_PAD));		addMouseListener(new MouseAdapter() {			@Override			public void mousePressed(MouseEvent me) {				int b = barAt(me.getPoint().x, me.getPoint().y);				if (b < 0) {					if (!me.isControlDown())						selections.clear(Histogram.this);					repaint();					return;				}				HistogramBarValue selectedBar = control.getBar(b);				selections.beginEditing(Histogram.this, false);				if (me.isShiftDown())					selectRange(b, anchorSelectionIndex);				else if (me.isControlDown())					selections.toggle(selectedBar, Histogram.this);				else					selections.setElements(selectedBar, Histogram.this);				if (!me.isShiftDown())					anchorSelectionIndex = b;				selections.endEditing(Histogram.this);				repaint();			}			@Override			public void mouseReleased(MouseEvent e) {				reviseMinMaxFromSelectionSet();			}		});		addMouseMotionListener(new MouseMotionAdapter() {			public void mouseDragged(MouseEvent me) {				selectRange(barAt(me.getPoint().x), anchorSelectionIndex);				repaint();			}		});		Dimension size = new Dimension(325,200);		setPreferredSize(size);		repaint();			} // end constructor		/**	 * returns the selection set object being used. this is either the one	 * provided to the constructor, generated internally otherwise.	 */	public SelectionSet getSelectionSet() {		return selections;	}		public void setSelectionSet(SelectionSet sel){		if (sel == null) return;		selections = sel;		reviseMinMaxFromSelectionSet();	}	private void reviseMinMaxFromSelectionSet(){		SelectionSet ss = this.selections;		if (ss.getElements().length == 0) return;		double minCenter = ((HistogramBarValue)ss.getElements()[0]).getXValue();		double maxCenter = minCenter;		for (int i = 1; i < ss.getElements().length; i++){			double centerValue = ((HistogramBarValue)ss.getElements()[i]).getXValue();			if (centerValue < minCenter) minCenter = centerValue;			if (centerValue > maxCenter) maxCenter = centerValue;		}		double halfWidth = control.getBarWidth() / 2.0;		control.setMinValue(minCenter-halfWidth);		control.setMaxValue(maxCenter-halfWidth);	}		private void selectRange(int b1, int b2) {		if (b1 < 0 || b2 < 0)			return;		selections.clear(this);		int range_start = Math.min(b1, b2);		int range_end = Math.max(b1, b2);		for (int i = range_start; i <= range_end; i++)			selections.addElement(control.getBar(i), Histogram.this);	}	private void computeBar(int barID, Rectangle rect) {		double barWidth = control.getBarWidth();		double barHeight = control.getBar(barID).getBarValue();		double barCenter = control.getBar(barID).getXValue();		rect.x = convertXValueToScreenValue(barCenter - (barWidth / 2.0));		rect.y = convertYValueToScreenValue(barHeight);		rect.height = convertHeightToScreenValue(barHeight);		rect.width = convertWidthToScreenValue(barWidth);	}	private int convertWidthToScreenValue(double width){		double chartWidth = getWidth() - (CHART_LEFT_PAD + CHART_RIGHT_PAD);		double barWidthPorportion = ( width / (control.getMaxMaxValue() - control.getMinMinValue()));		return (int)Math.round(chartWidth * barWidthPorportion);	}		private int convertHeightToScreenValue(double barHeight){		double chartHeight = getHeight() - (CHART_TOP_PAD + CHART_BOTTOM_PAD);		double chartBarHeight = barHeight / control.getMaxBarHeight() * chartHeight;		return (int)Math.round(chartBarHeight);	}		private int convertYValueToScreenValue(double barY) {		double chartHeight = getHeight() - (CHART_TOP_PAD + CHART_BOTTOM_PAD);		double chartBarHeight = barY /control.getMaxBarHeight() * chartHeight;		double chartY = chartHeight - chartBarHeight;		double y = CHART_TOP_PAD + chartY;		return (int)Math.round(y);	}		private int convertXValueToScreenValue(double x) {		double chart_width = getWidth() - (CHART_LEFT_PAD + CHART_RIGHT_PAD);		double offset = chart_width * (x - control.getMinMinValue()) / (control.getMaxMaxValue() - control.getMinMinValue());		double xPrime = CHART_LEFT_PAD + offset;		return (int)Math.round(xPrime);	}	public void paint(Graphics g) {		super.paint(g);		Point center = new Point(getWidth() / 2, getHeight() / 2);		if (g instanceof Graphics2D)			center.x -= stringWidth(NO_VALUES_MSG, g) / 2;		if (this.control.noBars()) {			g.drawString(NO_VALUES_MSG, center.x, center.y);			return;		}		// draw the data boxes//		int chart_width = getWidth() - (CHART_LEFT_PAD + CHART_RIGHT_PAD);//		int chartBarWidth = (int)Math.round( chart_width * ( control.getBarWidth() / (control.getMaxMaxValue() - control.getMinMinValue())));//		boolean drawBoxSeperators = chartBarWidth > MIN_BOX_WIDTH_FOR_SEPERATOR;		boolean drawBoxSeperators = false; // experimenting with appearance - tew 10/26/10				for (int i = 0; i < this.control.numberOfBars(); i++) {			computeBar(i, tmpRect);			Color barColor = control.getBarColor(i);//			g.setColor(selections.contains(this.control.getBar(i)) ? HIGHLIGHT_COLOR : barColor);			g.setColor(barColor);			g.fillRect(tmpRect.x, tmpRect.y, tmpRect.width, tmpRect.height);			g.setColor(Color.gray);			if (drawBoxSeperators && i > 0) // draw a line between each box pair				g.drawLine(tmpRect.x, tmpRect.y, tmpRect.x, tmpRect.y						+ tmpRect.height);		}		// draw the axes		g.setColor(Color.black);		Axis.drawAxis(Axis.X_AXIS, MAX_TIC_LABELS, TIC_LENGTH, 				(float)control.getMinMinValue(), (float)control.getMaxMaxValue(), // value range				CHART_LEFT_PAD, getWidth() - CHART_RIGHT_PAD, // screen range				CHART_BOTTOM_PAD, getHeight(), g);		Axis.drawAxis(Axis.Y_AXIS, MAX_TIC_LABELS, TIC_LENGTH,				0, (float)this.control.getMaxBarHeight(), // value range				CHART_BOTTOM_PAD, getHeight() - CHART_TOP_PAD, // screen range, lower-left axis				CHART_LEFT_PAD, getHeight(), g);		Font bold = g.getFont().deriveFont(Font.BOLD);		g.setFont(bold);		if (xAxisLabel != null) {			g.drawString(xAxisLabel, getWidth() - stringWidth(xAxisLabel, g)					- 20, getHeight() - 10);		}		if (yAxisLabel != null) {			g.drawString(yAxisLabel, CHART_LEFT_PAD - 40, 25);		}		// draw the Min and Max lines		int minX = convertXValueToScreenValue(control.getMinValue());		int maxX = convertXValueToScreenValue(control.getMaxValue());		g.setColor(control.getMinColor());		g.drawLine(minX, CHART_TOP_PAD , minX , getHeight() - CHART_BOTTOM_PAD);		g.setColor(control.getMaxColor());		g.drawLine(maxX, CHART_TOP_PAD , maxX , getHeight() - CHART_BOTTOM_PAD);			} // end paint	private int barAt(int x, int y) {		if (this.control.noBars())			return -1;		for (int i = 0; i < this.control.numberOfBars(); i++) {			computeBar(i, tmpRect);			if (rectContainsPoint(tmpRect, x, y))				return i;		}		return -1;	}	private static boolean rectContainsPoint(Rectangle rect, int x, int y) {		return rect.x <= x && x <= rect.x + rect.width && rect.y <= y				&& y <= rect.y + rect.height;	}	private int barAt(int x) {		if (this.control.noBars())			return -1;		for (int i = 0; i < this.control.numberOfBars(); i++) {			computeBar(i, tmpRect);			if (tmpRect.x <= x && x <= tmpRect.x + tmpRect.width)				return i;		}		return -1;	}	/**	 * handy little utility for determining the length in pixels the given	 * string will use if drawn into the given Graphics object.	 */	public static int stringWidth(String str, Graphics g) {		if (g instanceof Graphics2D)			return (int) (g.getFont().getStringBounds(str,					((Graphics2D) g).getFontRenderContext()).getWidth() + .5);		else			return g.getFontMetrics().stringWidth(str);	}	@Override	public void valuesChanged(MinMaxValueModel t) {		repaint();	}	@Override	public void colorRangeChanged(ColorRange selection) {		repaint();	}} // end class BarChart